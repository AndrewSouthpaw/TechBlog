We all have an origin story. Here's one of mine: how I became a programmer.

### Getting Started

My first dabbling with computer programming began in middle school, as I passed the time in classes by programming a "guess what number I'm thinking of" game on my TI-83. It was a humble beginning and not particularly fun to play, but the magic of creating something from nothing captivated me. (Also, as it turns out, I informally re-invented the binary search algorithm.) By reviewing the code of other games loaded onto my calculator, I cobbled together My First Program. (Granted, it was little more than some print statements, a while loop, if statements, and input prompts, but we all have to start with "Hello World" at some point.) From there, I took an interest in the burgeoning and mysterious land of the Internet. Referencing source code and a tutorial here and there, I crafted my own Geocities page with raw HTML. I bravely eschewed their website builder, partly because I wanted to understand how it all worked, and partly because I thought the code generated from the builder looked horrendous.

My lazy tinkering continued in high school: attending a summer school class on Visual Basic 5.0 (haha), attempting to read through a C++ book (I got stuck on hex conversions -- why they put that so close to the beginning is beyond me; pedagogical techniques have advanced a lot since the early 2000's). I made a brief foray into scripting while building worlds for Neverwinter Nights. The prospect of computer programming interested me, but I didn't take the study seriously; my attention was generally consumed by school and computer games.

For a long time, I seriously wanted to enroll at DigiPen and become a game programmer. As explained in [another post](http://www.andrewsouthpaw.com/2013/04/15/serendipitous-conversations-and-an-awakening/), I was dissuaded from that path. (I'm tempted to say "for the better," but one never knows for sure; indeed, my path is what it is; there can be no comparison because the other paths do not exist (omitting multiverses for the time being).) 

This decision was made before programming became the sexy thing to do among engineers thanks to Google and Apple; from my perspective, that happened a few years later around 2007. Software engineers was still reserved for the bespectacled and socially awkward, people I generally imagined stuck as cogs in a massive machine like IBM. Further, any research into reviews of CS programs uncovered flaming rants, decrying the anachronisms of such curriculum and putting forth their general worthlessness. ("By the time you graduate, the languages you have learned will be outdated," they would say.) To be honest, my research into the actual working conditions of software engineers at that time was embarassingly shallow. But, I was a high school student, so there it is. With my decision set to study Civil Engineering at the University of Portland, I sealed my fate to not touch programming for many years.

In graduate school, I toyed with the idea of taking some computer science classes. I made it through auditing a few weeks of the introductory CS106A course, before it fell by the wayside in the face of my many other responsibilities in school.

It took precisely three events to precipitate my serious delving into programming: a breakup, an email, and a conversation.

In the fall of 2012, I moved out to New York City in pursuit of a new woman and a new full-time career in dance. I put everything on the line, taking a leave of absence from my very successful graduate studies at Stanford University. Six months later, neither was working out. I felt like I had lost my way, gone adrift by departing from the standard accepted path (college --> graduate school --> work), and needing some direction. Away from school and from a stimulating academic environment for too long, a listless depression had settled in my heart. Meanwhile, I had decided to eschew all television watching and video gaming, because it was serving as an escape that only intensified my torpor. The removal of a relationship, television, and video games left a massive vacuum in my schedule; I desparately needed something to occupy my time. Crashing at a friends place, mired in self-pity and -loathing, wondering what I could do to get back on track, I received the email.

Listlessly purusing my inbox at night pretending to be productive, I opened a promotional email from StartX, the Stanford startup accelerator, which announced its recent batch of companies, most of which were tech-based. It got me thinking about all the activity and excitement that the tech industry had been receiving, and led to my lamenting the decision to not go into programming. It felt like I had missed the boat, one that promised opportunity and flexibility. My head swarming with emotions, I uncharacteristically reached out to a programmer friend of mine from Stanford, a fellow resident from my cooperative, and engaged in the conversation.

What followed did not go as expected. As I cried, "Alas, alack, I've missed the boat," he returned: "No, you haven't; you can teach yourself up to a hireable level easily within a year. You don't even need a degree, as long as you can provide your skills." How could such an incredible claim be possible? Could such an industry really exist, one that is so much more a meritocracy than any other?

An hour later, I created an account with Codecademy and started learning. I went to sleep around 4am that night, against my great desire to keep working through material. I felt empowered and inspired. I was learning again, pushing myself for the first time in many months. I didn't necessarily expect to make a career out of it, I just enjoyed the heck out of doing it. 

My foray into programming had, at last, begun in earnest.

### On and off

The following year and a half saw progress in fits and spurts, largely dictated by my dance teaching schedule. I would go through periods where I hardly touched a line of code, busy as I was touring around the US and Europe. Other times, I would log 40, 50, 60 hours of coding in a week. I genuinely looked forward to such opportunities, for I loved to learn new concepts and complete new tasks. The progress was obvious: whether understanding a new algorithm or wrapping my head around functional programming, I steadily built my scaffolding to then grasp even more complex topics.

While my sense of progress was evident, my direction was not. I had the three "core" Stanford CS classes to serve as a guide: CS106A (Programming Methodologies, Java), CS106B (Programming Abstractions, C++), and CS107 (Programming Paradigms, C).

###### CS106A

CS106A provided the perfect introduction to programming. Professor Sahami takes seriously the art of teaching. He would explain concepts clearly and often with my forms of learning (e.g. visualizations, analogies). He also was quite funny in class: showing up in costume, telling jokes, throwing candy at students that ask questions. (Also, though not because of his teaching style, some truly hilarious moments like [this one](http://youtu.be/iYtri45lhtc?t=31m34s).) Assignments were often game oriented, such as building Yahtzee. 

In addition to being highly enjoyable, the course presented many critical building blocks of programming: encapsulation, decomposition, and object-oriented programming, to name a few. It's fun to look back upon my lecture notes and see how far I've come -- a long way from the humble `while` loop.

###### CS106B

CS106B was the second step in my programming path. Bravely wading into C++ (despite the objections of peers at it being an "outdated" language), I learned about what runs under the hood of many programs. Data structures (arrays, queues, stacks, linked and doubly-linked lists, binary heaps, binary search trees) and data abstractions (vectors, maps, sets) were covered in the course, as we peeled off the top layer to see the mechanics running underneath. Other core topics included recursion strategies and algorithms. Working with C++ made me feel much "closer" to the machine, particularly once we began manipulating pointers. As far as content goes, this has been my best class: the concepts covered have stayed with me since then.

I never made it to CS107, sidetracked by other learning opportunities. While working through CS106B, I stumbled through a few different Coursera classes: Introduction to Programming (Python), Functional Programming in Scala, Programming Languages, and Algorithms.

###### Python

The Python class was enjoyable, though nothing ground-breaking. Already having a sound background in the basics, I took this class more for the introduction to the language. It was fun and quick, and now I have some familiarity.

###### Scala

The Scala class cleaned the floor with my face. I had never encountered functional programming at that point, and this class did not have the best instructor to impart the concepts. The course was made doubly challenging by working with an utterly unfamiliar syntax. I'm glad I did it, passing the course with distinction, but it was a grueling process and probably not timed well.

###### Programming Languages

Programming Languages came as the followup to the Scala course. Mirroring the course at University of Washington, it covered abstract concepts in programming languages centered around the exploration of a 2x2 matrix: functional vs. object-oriented programming, and static v. dynamic typing. We looked at three of the four.

                   Static      Dynamic
                ------------------------
    Functional  |   ML       |  Racket |  
                ------------------------
    OOP         |  Java/etc  |   Ruby  |
                ------------------------

It was an advanced course, intended for second-year CS majors. The professor, Dan Boneh, didn't pull any punches with this material. While endeavoring to be clear and concise, he never dumbed down the approach. As it was, I'd say it was a little over my head at the time. Mixins, duck typing, parsers, double dispatch, structs, polymorphism, lambdas, closures, blocks, the list goes on and on, and many of them didn't quite stick. I don't feel terrible about this fact -- my guess would be many engineers couldn't throw down a double dispatch on the spot, so I'm not alone. But they're valuable tools and I will doubtless revisit the course later on to bolster my understanding.

The most valuable outcome from the course, however, was to firmly grasp functional programming and higher-order functions. Maybe it was because I just squeezed my way through the Scala course. But I think it was because ML provides a clear and intuitive look into the mechanics of functional programming. Plus, I think Professor Boneh is a better teacher. Whatever the reason, I walked away from the course knowing FP much, much better, which would come hugely in useful when I reached JavaScript.

###### Algorithms I

The algorithms course, taught by Tim Roughgarden, the first half of the Stanford algorithms course CS161, was precisely what one would expect: a deep-dive into algorithmic analysis. A valuable class, taught quite well. My eyes tended to glaze over whenever mathematical symbols splayed onto the screen to provide a proof of correctness, but I managed my way through it. I'm pretty good at holding onto material long enough to make it through a class, even if it's difficult or unintuitive. It is, however, less likely to stick long-term in my mind. Without much occasion to regularly practice the random contraction algorithm, many finer points of the class have faded away.

### A summer of web development

By the time I finished all these courses, an entire year had passed. I was living large as a nomadic dance instructor, working on weekends and coding during the weekdays from coffee shops around the world. It was a good life. Coding was still something I did for fun, as I held out for a reentry into the sustainable construction industry. But, as my time in programming had been so rewarding, and the work style can fit quite nicely with a traveling instructor, I began to open up my mind to the possibility of working professionally. Meanwhile, I was growing concerned about ever-lengthening time away from the engineering industry, and wondering if the black hole of no work experience on my resume would mar me forever. Thus the stage was set for yet another significant email to cross my inbox.

In late April of 2014, I happened upon an internship posting, forwarded through the many mailing lists of Stanford. Gmail had flagged it as "unimportant." Procrastination had me picking my way through those messages, and dumb luck had me open it and take it seriously. An internship at a SF-based sustainability startup, looking for engineers with experience in building systems and energy, sustainability, and programming. What could be a better fit? After some debating whether it really was time for a re-entry into the engineering field, I dusted off my resume, spent many hours on a cover letter, and submitted my application bundled with a healthy dose of hope. A few weeks and [a rather crazy story](http://andrewsouthpaw.blogspot.com/2014/06/a-rare-opportunity-new-adventure-return.html) later, I had landed the internship.

I was accepted to Hack Reactor shortly after the news arrived about Carbon Lighthouse. June was, needless to say, a heady time for me. Everything was feeling on the up and up: here I was, wrapping up a successful 3-month tour of Europe, about to gain real-world programming experience and a sustainability startup and then join a prestigious bootcamp to massively expand my skillset and become a bonafide software engineer. Hack Reactor offered the "stamp of approval" that I desparately sought (since I could not look to a B.S. to provide it), some reasonable "guarantee" that I'd actually get a job. I could hardly contain myself.

The internship was a dream come true, but I'll skip to the pertinent bits for this story.

For about two months, I worked full-time developing a web application for the company, designed to support the operations of their engineers in the field. With only my middle-school website experience and some basic JavaScript under my belt, I had a lot to learn. No one in the team had any web development experience, and only one knew a bit about PostgreSQL, so I was once again teaching myself everything necessary. 

I taught myself JavaScript, HTML, CSS, jQuery, Twitter Bootstrap, and a slew of new-fangled HTML5 features to make the app fit the needs of the company. Be able to take photos and put them on the page? Sure, I'm sure I'll be able to figure that out. *Cue montage of me poring over StackOverflow discussions and banging my head against a desk, trying to understand a particular security error.* Scan barcodes? No problem, I bet that will be doable. *Cue montage of many many hours spent trying out different technologies, and trying to learn the background material necessary to then compare the technologies to decide which one to* try *to implement on my app.*

Part of the challenge (and the fun) of the internship was knowing what I wanted to do, but having no clue how to get there. Sometimes the path was straightforward; for example, I needed to be able to manipulate objects on the page, so I took some online courses on jQuery through CodeSchool. (CodeSchool came quite in handy for much of my base knowledge in web development. I already had a subscription before the internship, and used it heavily during my time there.) But other times, the path was like walking through a dark forest without a flashlight, guided only by the occasion faint whistle to steer my path.

Let's take the barcode scanning as an illustrative example. The goal was for an engineer to take scan device barcodes in the field, thus easily drawing them up on the page for note taking. Okay, barcode scanning, Google "barcode scanning," open five or so tabs, and start down the rabbit hole. Occasionally come up for air, lunch, or a Pomodoro break. Okay, looks like there's different technologies: an external device, the Barcode Scanner App (for Android) and the open-source ZXing library that backs it, a few JavaScript implementations. Do they work? The Barcode Scanner App definitely works, but that's a separate app, so it would have to integrate somehow with the website. JavaScript implementations sometimes worked, sometimes didn't -- they were generally unreliable and I had a hard time understanding how to use them myself. Okay, so go with Barcode Scanner. Is it possible? *Googling...* Ah! A solution! I'll just paste that in there and... nope, that doesn't work. *More hours go by.* Hah! Okay! So all I need to do is use a special callback that routes to a designated separate page within the app to then extract the barcode and send the information back to app. Great, how do I do that? PHP? *Googling...* Okay, awesome! I'm the best! *Run a couple more spot tests.* Hmm, now you've set up a race condition on whether the PHP page extracts the barcode and sends it back before the app reloads itself. *More Googling...* Okay, you could try to make the webpage wait, but that's hard to do with good style in JavaScript, which generally runs asynchronously -- what the heck does asynchronous mean? *Still more Googling...* You get the idea.

![What programming is like](/content/images/2014/12/programming-2013-04-15-273.png)
(Source: [Three Panel Soul](http://threepanelsoul.com/))

Despite the challenging circumstances, I grew a lot through the process and achieved most of the original project objectives. I had built a mostly functional product. It did not integrate with existing Excel workflows, did not provide the backend that I had hoped, did not yet have error-proof offline storage and syncing. But it worked, and it could be tested by engineers in the field, and I'm exceedingly proud of that fact. Plus, when I demoed it to the group, they all ooh'ed and ahh'ed at the appropriate times. I had clearly done a fine job identifying their pain points, iterating regularly and always driving toward the design requirements, and delivering a well-informed and thoughtfully architected solution.

### The road to Hack Reactor

I walked out of my internship feeling like a bonafide front-end web developer. My time had Carbon Lighthouse was its own sort of bootcamp, and I had benefitted enormously from it. It bolstered my confidence in the path I had taken, and that I could indeed get a job as a software engineer. I even became convinced that I could achieve it on my own, with several more months of hard work and diligence. No longer believing that I "needed" Hack Reactor to get a job, I spent a long and hard time deliberating if it was still worth it. [In the end](http://andrewsouthpaw.blogspot.com/2014/12/my-reasons-for-attending-hack-reactor.html), I decided it was. 

Since the conclusion of my internship in mid-October (technically it was a summer internship, but I started in late June and took off an entire month for other teaching work that was previously booked), I have been blasting through the precourse material for Hack Reactor. It's all stuff I've experienced before, so I took great pleasure in finishing the basic requirements with ease and then digging into the extra credit material, or going even beyond and inventing my own ways to continue learning on the topic. For example, after going through the Backbone courses on CodeSchool, I revisited a webpage built for one of the assignments and refactored everything using the new framework. 

Which brings me to now: flying from Amsterdam back to the United States, Hack Reactor less than a week away. It's amazing to see how far I've progressed, and I'm glad for the occasional blog post I've written along the way to document my path. I still distinctly remember my first time implementing recursion in the first CS106A homework assignment -- long before recursion would be discussed in class -- based upon an exceedingly vague recollection of recursion from my summer school class in high school.

![Celebrating recursive solution](/content/images/2014/12/Screen-Shot-2014-12-04-at-2-34-49-PM-1.png)

Now it's time to become a professional software engineer.
